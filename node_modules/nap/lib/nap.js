// Generated by CoffeeScript 1.3.1
(function() {
  var coffee, crypto, embedFiles, exec, fileUtil, fingerprintCache, fingerprintForPkg, fs, generateJSTs, glob, gzipPkg, hogan, hoganPrefix, jade, jadeRuntime, less, mkdirp, nib, path, preprocess, preprocessPkg, preprocessors, rimraf, sqwish, styl, templateParsers, uglify, uglifyjs, writeFile, _,
    _this = this;

  fs = require('fs');

  path = require('path');

  exec = require('child_process').exec;

  coffee = require('coffee-script');

  styl = require('stylus');

  less = require('less');

  nib = require('nib');

  jade = require('jade');

  jadeRuntime = fs.readFileSync(path.resolve(__dirname, '../deps/jade.runtime.js')).toString();

  hogan = require('hogan');

  hoganPrefix = fs.readFileSync(path.resolve(__dirname, '../deps/hogan.js')).toString();

  sqwish = require('sqwish');

  uglifyjs = require("uglify-js");

  _ = require('underscore');

  _.mixin(require('underscore.string'));

  mkdirp = require('mkdirp');

  fileUtil = require('file');

  glob = require('glob');

  rimraf = require('rimraf');

  crypto = require('crypto');

  module.exports = function(options) {
    var appDir, ext, file, filename, fnd, key, matches, obj, pattern, patterns, pkg, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    if (options == null) {
      options = {};
    }
    _this.assets = options.assets;
    if (_this.assets == null) {
      throw new Error("You must specify an 'assets' obj with keys 'js', 'css', or 'jst'");
    }
    appDir = process.cwd().replace(/\\/g, "\/");
    _ref = _this.assets;
    for (key in _ref) {
      obj = _ref[key];
      _ref1 = _this.assets[key];
      for (pkg in _ref1) {
        patterns = _ref1[pkg];
        matches = [];
        for (_i = 0, _len = patterns.length; _i < _len; _i++) {
          pattern = patterns[_i];
          fnd = glob.sync(path.resolve("" + appDir + "/" + pattern).replace(/\\/g, "\/"));
          matches = matches.concat(fnd);
        }
        matches = _.uniq(_.flatten(matches));
        matches = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = matches.length; _j < _len1; _j++) {
            file = matches[_j];
            _results.push(file.replace(appDir, '').replace(/^\//, ''));
          }
          return _results;
        })();
        _this.assets[key][pkg] = matches;
      }
    }
    _this.publicDir = (_ref2 = options.publicDir) != null ? _ref2 : '/public';
    _this.mode = (_ref3 = options.mode) != null ? _ref3 : (function() {
      switch (process.env.NODE_ENV) {
        case 'staging':
          return 'production';
        case 'production':
          return 'production';
        default:
          return 'development';
      }
    })();
    _this.cdnUrl = options.cdnUrl != null ? options.cdnUrl.replace(/\/$/, '') : void 0;
    _this.embedImages = (_ref4 = options.embedImages) != null ? _ref4 : false;
    _this.embedFonts = (_ref5 = options.embedFonts) != null ? _ref5 : false;
    _this.gzip = (_ref6 = options.gzip) != null ? _ref6 : false;
    _this.fingerprint = (_ref7 = options.fingerprint) != null ? _ref7 : false;
    _this._tmplPrefix = 'window.JST = {};\n';
    _this._assetsDir = '/assets';
    _this._outputDir = path.normalize(_this.publicDir + _this._assetsDir);
    if (!path.existsSync(process.cwd() + _this.publicDir)) {
      throw new Error("The directory " + _this.publicDir + " doesn't exist");
    }
    rimraf.sync("" + (process.cwd()) + "/" + _this.publicDir + "/assets");
    if (!_this.usingMiddleware) {
      fs.mkdirSync(process.cwd() + _this._outputDir, '0755');
      fs.writeFileSync("" + (process.cwd()) + "/" + _this._outputDir + "/.gitignore", "/*");
    }
    _ref8 = _.flatten(_this.assets.jst);
    for (_j = 0, _len1 = _ref8.length; _j < _len1; _j++) {
      filename = _ref8[_j];
      ext = path.extname(filename);
      switch (ext) {
        case '.jade':
          _this._tmplPrefix = jadeRuntime + '\n' + _this._tmplPrefix;
          break;
        case '.mustache':
          _this._tmplPrefix = hoganPrefix + '\n' + _this._tmplPrefix;
      }
    }
    return _this;
  };

  module.exports.js = function(pkg, gzip) {
    var contents, filename, fingerprint, output, src, _ref, _ref1;
    if (gzip == null) {
      gzip = _this.gzip;
    }
    if (_this.assets.js[pkg] == null) {
      throw new Error("Cannot find package '" + pkg + "'");
    }
    if (_this.mode === 'production') {
      if (_this.fingerprint) {
        fingerprint = '-' + fingerprintForPkg('js', pkg);
      }
      src = ((_ref = _this.cdnUrl) != null ? _ref : _this._assetsDir) + '/' + ("" + pkg + (fingerprint != null ? fingerprint : '') + ".js");
      if (gzip) {
        src += '.jgz';
      }
      return "<script src='" + src + "' type='text/javascript'></script>";
    }
    output = '';
    _ref1 = preprocessPkg(pkg, 'js');
    for (filename in _ref1) {
      contents = _ref1[filename];
      if (!_this.usingMiddleware) {
        writeFile(filename, contents);
      }
      output += "<script src='" + _this._assetsDir + "/" + filename + "' type='text/javascript'></script>";
    }
    return output;
  };

  module.exports.css = function(pkg, gzip) {
    var contents, filename, fingerprint, output, src, _ref, _ref1;
    if (gzip == null) {
      gzip = _this.gzip;
    }
    if (_this.assets.css[pkg] == null) {
      throw new Error("Cannot find package '" + pkg + "'");
    }
    if (_this.fingerprint) {
      fingerprint = '?' + fingerprintForPkg('css', pkg);
    }
    if (_this.mode === 'production') {
      src = ((_ref = _this.cdnUrl) != null ? _ref : _this._assetsDir) + '/' + ("" + pkg + (fingerprint != null ? fingerprint : '') + ".css");
      if (gzip) {
        src += '.cgz';
      }
      return "<link href='" + src + "' rel='stylesheet' type='text/css'>";
    }
    output = '';
    _ref1 = preprocessPkg(pkg, 'css');
    for (filename in _ref1) {
      contents = _ref1[filename];
      if (!_this.usingMiddleware) {
        writeFile(filename, embedFiles(filename, contents));
      }
      output += "<link href='" + _this._assetsDir + "/" + filename + (fingerprint != null ? fingerprint : '') + "' rel='stylesheet' type='text/css'>";
    }
    return output;
  };

  module.exports.jst = function(pkg, gzip) {
    var fingerprint, src, _ref;
    if (gzip == null) {
      gzip = _this.gzip;
    }
    if (_this.assets.jst[pkg] == null) {
      throw new Error("Cannot find package '" + pkg + "'");
    }
    if (_this.mode === 'production') {
      if (_this.fingerprint) {
        fingerprint = '-' + fingerprintForPkg('jst', pkg);
      }
      src = ((_ref = _this.cdnUrl) != null ? _ref : _this._assetsDir) + '/' + ("" + pkg + (fingerprint != null ? fingerprint : '') + ".jst.js");
      if (gzip) {
        src += '.jgz';
      }
      return "<script src='" + src + "' type='text/javascript'></script>";
    }
    if (!_this.usingMiddleware) {
      fs.writeFileSync(process.cwd() + _this._outputDir + '/' + pkg + '.jst.js', generateJSTs(pkg));
      fs.writeFileSync(process.cwd() + _this._outputDir + '/nap-templates-prefix.js', _this._tmplPrefix);
    }
    return "<script src='" + _this._assetsDir + "/nap-templates-prefix.js' type='text/javascript'></script>\n<script src='" + _this._assetsDir + "/" + pkg + ".jst.js' type='text/javascript'></script>";
  };

  module.exports["package"] = function(callback) {
    var contents, filename, files, fingerprint, finishCallback, fn, key, pkg, pkgs, total, _ref, _ref1, _ref2, _results;
    total = _.reduce((function() {
      var _ref, _results;
      _ref = this.assets;
      _results = [];
      for (key in _ref) {
        pkgs = _ref[key];
        _results.push(_.values(pkgs).length);
      }
      return _results;
    }).call(_this), function(memo, num) {
      return memo + num;
    });
    finishCallback = _.after(total, function() {
      if (callback != null) {
        return callback();
      }
    });
    if (_this.assets.js != null) {
      _ref = _this.assets.js;
      for (pkg in _ref) {
        files = _ref[pkg];
        contents = ((function() {
          var _ref1, _results;
          _ref1 = preprocessPkg(pkg, 'js');
          _results = [];
          for (fn in _ref1) {
            contents = _ref1[fn];
            _results.push(contents);
          }
          return _results;
        })()).join('');
        if (_this.mode === 'production') {
          contents = uglify(contents);
        }
        if (_this.fingerprint) {
          fingerprint = '-' + fingerprintForPkg('js', pkg);
        }
        filename = "" + pkg + (fingerprint != null ? fingerprint : '') + ".js";
        writeFile(filename, contents);
        if (_this.gzip) {
          gzipPkg(contents, filename, finishCallback);
        } else {
          finishCallback();
        }
        total++;
      }
    }
    if (_this.assets.css != null) {
      _ref1 = _this.assets.css;
      for (pkg in _ref1) {
        files = _ref1[pkg];
        contents = ((function() {
          var _ref2, _results;
          _ref2 = preprocessPkg(pkg, 'css');
          _results = [];
          for (filename in _ref2) {
            contents = _ref2[filename];
            _results.push(embedFiles(filename, contents));
          }
          return _results;
        })()).join('');
        if (_this.mode === 'production') {
          contents = sqwish.minify(contents);
        }
        if (_this.fingerprint) {
          fingerprint = '-' + fingerprintForPkg('css', pkg);
        }
        filename = "" + pkg + (fingerprint != null ? fingerprint : '') + ".css";
        writeFile(filename, contents);
        if (_this.gzip) {
          gzipPkg(contents, filename, finishCallback);
        } else {
          finishCallback();
        }
        total++;
      }
    }
    if (_this.assets.jst != null) {
      _ref2 = _this.assets.jst;
      _results = [];
      for (pkg in _ref2) {
        files = _ref2[pkg];
        contents = generateJSTs(pkg);
        contents = _this._tmplPrefix + contents;
        if (_this.mode === 'production') {
          contents = uglify(contents);
        }
        if (_this.fingerprint) {
          fingerprint = '-' + fingerprintForPkg('jst', pkg);
        }
        filename = "" + pkg + (fingerprint != null ? fingerprint : '') + ".jst.js";
        writeFile(filename, contents);
        if (_this.gzip) {
          gzipPkg(contents, filename, finishCallback);
        } else {
          finishCallback();
        }
        _results.push(total++);
      }
      return _results;
    }
  };

  module.exports.middleware = function(req, res, next) {
    var contents, filename, filenames, pkg, _i, _j, _len, _len1, _ref, _ref1;
    if (_this.mode !== 'development') {
      next();
      return;
    }
    _this.usingMiddleware = true;
    switch (path.extname(req.url)) {
      case '.css':
        if (typeof res.setHeader === "function") {
          res.setHeader("Content-Type", "text/css");
        }
        _ref = _this.assets.css;
        for (pkg in _ref) {
          filenames = _ref[pkg];
          for (_i = 0, _len = filenames.length; _i < _len; _i++) {
            filename = filenames[_i];
            if (req.url.replace(/^\/assets\/|.(?!.*\.).*/g, '') === filename.replace(/.(?!.*\.).*/, '')) {
              contents = fs.readFileSync(path.resolve(process.cwd() + '/' + filename)).toString();
              contents = preprocess(contents, filename);
              res.end(contents);
              return;
            }
          }
        }
        break;
      case '.js':
        if (typeof res.setHeader === "function") {
          res.setHeader("Content-Type", "application/javascript");
        }
        if (req.url.match(/\.jst\.js$/)) {
          pkg = path.basename(req.url, '.jst.js');
          res.end(generateJSTs(pkg));
          return;
        }
        if (req.url.match(/nap-templates-prefix\.js$/)) {
          res.end(_this._tmplPrefix);
          return;
        }
        _ref1 = _this.assets.js;
        for (pkg in _ref1) {
          filenames = _ref1[pkg];
          for (_j = 0, _len1 = filenames.length; _j < _len1; _j++) {
            filename = filenames[_j];
            if (req.url.replace(/^\/assets\/|.(?!.*\.).*/g, '') === filename.replace(/.(?!.*\.).*/, '')) {
              contents = fs.readFileSync(path.resolve(process.cwd() + '/' + filename)).toString();
              contents = preprocess(contents, filename);
              res.end(contents);
              return;
            }
          }
        }
    }
    return next();
  };

  module.exports.preprocessors = preprocessors = {
    '.coffee': function(contents, filename) {
      return coffee.compile(contents);
    },
    '.styl': function(contents, filename) {
      styl(contents).set('filename', process.cwd() + '/' + filename).use(nib()).render(function(err, out) {
        if (err) {
          throw err;
        }
        return contents = out;
      });
      return contents;
    },
    '.less': function(contents, filename) {
      less.render(contents, function(err, out) {
        if (err) {
          throw err;
        }
        return contents = out;
      });
      return contents;
    }
  };

  module.exports.templateParsers = templateParsers = {
    '.jade': function(contents, filename) {
      return jade.compile(contents, {
        client: true,
        compileDebug: true
      });
    },
    '.mustache': function(contents, filename) {
      return 'new Hogan.Template(' + hogan.compile(contents, {
        asString: true
      }) + ')';
    }
  };

  module.exports.generateJSTs = generateJSTs = function(pkg) {
    var contents, ext, filename, namespace, tmplFileContents, _i, _len, _ref;
    tmplFileContents = '';
    _ref = _this.assets.jst[pkg];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      filename = _ref[_i];
      contents = fs.readFileSync(path.resolve(process.cwd() + '/' + filename)).toString();
      ext = path.extname(filename);
      contents = templateParsers[ext] != null ? templateParsers[ext](contents, filename) : contents;
      if (filename.indexOf('templates') > -1) {
        namespace = filename.split('templates').slice(-1)[0].replace(/^\/|\..*/g, '');
      } else {
        namespace = filename.split('/').slice(-1)[0].replace(/^\/|\..*/g, '');
      }
      tmplFileContents += "JST['" + namespace + "'] = " + contents + ";\n";
    }
    return tmplFileContents;
  };

  preprocess = function(contents, filename) {
    var ext;
    ext = path.extname(filename);
    if (preprocessors[ext] != null) {
      return preprocessors[ext](contents, filename);
    } else {
      return contents;
    }
  };

  preprocessPkg = function(pkg, type) {
    var contents, filename, obj, outputFilename, _i, _len, _ref;
    obj = {};
    _ref = _this.assets[type][pkg];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      filename = _ref[_i];
      contents = fs.readFileSync(path.resolve(process.cwd() + '/' + filename)).toString();
      contents = preprocess(contents, filename);
      outputFilename = filename.replace(/\.[^.]*$/, '' + '.' + type);
      obj[outputFilename] = contents;
    }
    return obj;
  };

  writeFile = function(filename, contents) {
    var dir, file;
    file = process.cwd() + _this._outputDir + '/' + filename;
    dir = path.dirname(file);
    if (!path.existsSync(dir)) {
      mkdirp.sync(dir, '0755');
    }
    return fs.writeFileSync(file, contents != null ? contents : '');
  };

  uglify = function(str) {
    var ast, jsp, pro;
    jsp = uglifyjs.parser;
    pro = uglifyjs.uglify;
    ast = jsp.parse(str);
    ast = pro.ast_mangle(ast);
    ast = pro.ast_squeeze(ast);
    return pro.gen_code(ast);
  };

  embedFiles = function(filename, contents) {
    var base64Str, end, endsWithEmbed, i, mime, mimes, newUrl, offset, offsetContents, start, _i, _ref;
    endsWithEmbed = _.endsWith(path.basename(filename).split('.')[0], '_embed');
    if (!(contents != null) || contents === '' || !endsWithEmbed) {
      return contents;
    }
    mimes = {};
    if (_this.embedImages) {
      mimes = _.extend({
        '.gif': 'image/gif',
        '.png': 'image/png',
        '.jpg': 'image/jpeg',
        '.jpeg': 'image/jpeg',
        '.svg': 'image/svg+xml'
      }, mimes);
    }
    if (_this.embedFonts) {
      mimes = _.extend({
        '.ttf': 'font/truetype;charset=utf-8',
        '.woff': 'font/woff;charset=utf-8',
        '.svg': 'image/svg+xml'
      }, mimes);
    }
    if (_.isEmpty(mimes)) {
      return contents;
    }
    offset = 0;
    offsetContents = contents.substring(offset, contents.length);
    if (offsetContents.match(/url/g) == null) {
      return contents;
    }
    for (i = _i = 0, _ref = offsetContents.match(/url/g).length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      start = offsetContents.indexOf('url(') + 4 + offset;
      end = contents.substring(start, contents.length).indexOf(')') + start;
      filename = _.trim(_.trim(contents.substring(start, end), '"'), "'");
      filename = process.cwd() + _this.publicDir + '/' + filename.replace(/^\//, '');
      mime = mimes[path.extname(filename)];
      if (mime != null) {
        if (path.existsSync(filename)) {
          base64Str = fs.readFileSync(path.resolve(filename)).toString('base64');
          newUrl = "data:" + mime + ";base64," + base64Str;
          contents = _.splice(contents, start, end - start, newUrl);
          end = start + newUrl.length + 4;
        } else {
          throw new Error('Tried to embed data-uri, but could not find file ' + filename);
        }
      } else {
        end += 4;
      }
      offset = end;
      offsetContents = contents.substring(offset, contents.length);
    }
    return contents;
  };

  gzipPkg = function(contents, filename, callback) {
    var ext, file;
    file = "" + (process.cwd() + _this._outputDir + '/') + filename;
    ext = _.endsWith(filename, '.js') ? '.jgz' : '.cgz';
    return exec("gzip " + file, function(err, stdout, stderr) {
      if (stderr) {
        console.log(stderr);
      }
      fs.renameSync(file + '.gz', file + ext);
      writeFile(filename, contents);
      return callback();
    });
  };

  fingerprintCache = {
    js: {},
    jst: {},
    css: {}
  };

  fingerprintForPkg = function(pkgType, pkgName) {
    var file, md5;
    if (fingerprintCache[pkgType][pkgName] != null) {
      return fingerprintCache[pkgType][pkgName];
    }
    md5 = crypto.createHash('md5');
    md5.update(((function() {
      var _i, _len, _ref, _results;
      _ref = this.assets[pkgType][pkgName];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        _results.push(file + fs.statSync(file).size);
      }
      return _results;
    }).call(_this)).join(''));
    return fingerprintCache[pkgType][pkgName] = md5.digest('hex');
  };

}).call(this);
